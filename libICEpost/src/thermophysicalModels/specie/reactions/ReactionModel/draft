#To solve the reaction scheme, generate a linear system 
# of equations with:
#   n unknowns (chemical specie in reactants)
#   m constrains (the mixtures of reactants in each reaction)
#
#Then the solution is obtained finding the intersection of all
#constrains (finding null space of the matrix of coefficients)
#
#   R0: alpha*[a0*A + b0*B + ...]   | Reactants reaction R0
#   R1: beta* [a0*A + b0*B + ...]   | Reactants reaction R1
#   R2: gamma*[a0*A + b0*B + ...]   | Reactants reaction R2
#   ------------------------------
#   Rtot: a*A + b*B + ...           | Overall reactants
#
#   {A,B,...}: Chemical specie
#   {R0,R1,...}: Reactions [Also the simple reactions (A -> A)]
#
#   |alpha*a0 + beta*a1 + gamma*a2 ... = a
#   |alpha*b0 + beta*b1 + gamma*b2 ... = b
#   |...
#
#   | a0  a1  a2  ... | |alpha| |a|
#   | b0  b1  b2  ... |*|beta |=|b|
#   | ...             | |...  | |.|
#
#   [M]*x = v
#
#If the solution is under-determined, an additional constrain is
#to preserve the ratio between the molar fractions of excess 
# reactants [infinitely fast chemistry with same chemical kinetics]

#Create the extended matrix |M|v| initialized to zero, then fill
M = self.np.array([[0. for a in range(len(activeReactions)+len(reactingMix))] for b in range(len(reactingMix))])
v = self.np.array([s["X"] for s in reactingMix])

print(M)
#Fill the coefficients of reactions (M)
for ii, react in enumerate(activeReactions):
for jj, s in enumerate(reactingMix):
    if s["specie"] in react.reactants:
        M[jj][ii] = react.reactants[s["specie"]]["X"]
print(M)

#Categorize based on reactants involved in the highest 
# number of reactions. These should be consumed first 
# and so compared with the remaining reactants to assess 
# if they are deficient reactants.
#