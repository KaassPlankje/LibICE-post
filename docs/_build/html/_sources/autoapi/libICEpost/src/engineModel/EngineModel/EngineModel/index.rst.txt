libICEpost.src.engineModel.EngineModel.EngineModel
==================================================

.. py:module:: libICEpost.src.engineModel.EngineModel.EngineModel

.. autoapi-nested-parse::

   @author: F. Ramognino       <federico.ramognino@polimi.it>
   Last update:        12/06/2023



Classes
-------

.. autoapisummary::

   libICEpost.src.engineModel.EngineModel.EngineModel.EngineModel


Module Contents
---------------

.. py:class:: EngineModel(*, time: libICEpost.src.engineModel.EngineTime.EngineTime.EngineTime, geometry: libICEpost.src.engineModel.EngineGeometry.EngineGeometry.EngineGeometry, thermophysicalProperties: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary, combustionProperties: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary, dataDict: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary = None, **submodels)

   Bases: :py:obj:`libICEpost.src.base.BaseClass.BaseClass`


   Base class for modeling of an engine and processing experimental/numerical data

   NOTE:
   For naming of variables:
       -> By default they refer to the "cylinder" zone
       -> Variables referred to a specific zone are allocated as "<variableName>_<zoneName>"

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   TODO: documentation and user info



   .. py:attribute:: _cylinder
      :type:  libICEpost.src.thermophysicalModels.thermoModels.ThermoModel.ThermoModel

      Cylinder thermodynamic region


   .. py:attribute:: Types
      :type:  dict[str:type]

      Types for each main model


   .. py:attribute:: Submodels
      :type:  dict[str:type]

      The available sub-models and their default initializers


   .. py:attribute:: Zones
      :type:  list[str]
      :value: ['cylinder']


      The zones avaliable in the model


   .. py:attribute:: thermophysicalProperties
      :type:  libICEpost.src.base.dataStructures.Dictionary.Dictionary

      Dictionary with thermophysical properties for mixtures


   .. py:attribute:: combustionProperties
      :type:  libICEpost.src.base.dataStructures.Dictionary.Dictionary

      Dictionary with properties for combustion modeling and chemical composition of mixtures


   .. py:attribute:: CombustionModel
      :type:  EngineModel.CombustionModel

      The combustion model


   .. py:attribute:: EgrModel
      :type:  EngineModel.EgrModel

      The EGR model


   .. py:attribute:: HeatTransferModel
      :type:  EngineModel.HeatTransferModel

      The wall heat transfer model


   .. py:attribute:: _air
      :type:  libICEpost.Database.chemistry.specie.Mixtures.Mixture

      Air mixture


   .. py:attribute:: info
      :type:  libICEpost.src.base.dataStructures.Dictionary.Dictionary

      General information for pre-post processing


   .. py:property:: raw
      :type: libICEpost.src.base.dataStructures.EngineData.EngineData.EngineData

      The raw data

      :returns: EngineData


   .. py:property:: data
      :type: libICEpost.src.base.dataStructures.EngineData.EngineData.EngineData

      The processed/filtered data

      :returns: EngineData


   .. py:method:: fromDictionary(dictionary: libICEpost.src.base.dataStructures.Dictionary.Dictionary) -> EngineModel
      :classmethod:


      Construct from dictionary like:
      {
          EngineTime:         str
              Name of the EngineTime model to use
          <EngineTime>Dict:   dict
              Dictionary containing the data specific of the selected
              SngineTime model (e.g., if engineTime is 'SparkIgnitionTime',
              then this dictionary must be named 'SparkIgnitionTimeDict').
              See at the helper for function 'fromDictionary' of the specific
              EngineTime model selected.

          EngineGeometry:         str
              Name of the EngineGeometry model to use
          <EngineGeometry>Dict:   dict
              Dictionary with data required from engineGeometry.
              See at the helper for function 'fromDictionary' of the specific
              EngineGeometry model selected.

          thermoPhysicalProperties:   dict
              Dictionary with types and data for thermophysical modeling of mixtures
          {
              ThermoType: dict
              {
                  Thermo: str
                  EquationOfState:    str
              }
              <Thermo>Dict: dict
              <EquationOfState>Dict: dict
          }

          combustionProperties:   dict
              Dictionaries for data required for mixture preparation and combustion modeling.
          {
              injectionModels: dict
              {
                  TODO
              },

              air:    Mixture (default: database.chemistry.specie.Mixtures.dryAir)
                  The air mixture composition

              initialMixture: dict
                  Dictionary with data for initialization of the mixture
                  in the thermodynamic zones
              {
                  <zoneName>:
                  {
                      [depends on specific engine model]
                  }
              },

              CombustionModel:         str
                  Name of the CombustionModel to use
              <CombustionModel>Dict:   dict
                  Dictionary with data required from CombustionModel
                  See at the helper for function 'fromDictionary' of the specific
                  CombustionModel model selected.
          }

          dataDict (dictionary): Dictionary with info for loading data, pre-processing and setting initial conditions.
          {
              TODO
          }
      }



   .. py:method:: _constructThemodynamicModels(combustionProperties: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary) -> EngineModel

      Construct the thermodynamic models of the system, setting their initial
      mixture composition. Here setting everything to air, might be overwritten
      in sub-classes to handle specific initializations (SI engine will use
      the premixedFuel entry)

      :param combustionProperties: the combustion properties
      :type combustionProperties: dict|Dictionary

      :returns: self
      :rtype: EngineModel



   .. py:method:: _constructEgrModel(combustionProperties: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary)

      Construct the EGR model and apply it to the cylinder region.
      Might be overwritten in child for applying EGR also to sub-regions of cylinder.

      :param combustionProperties: the combustion properties
      :type combustionProperties: dict|Dictionary

      :returns: self
      :rtype: EngineModel



   .. py:method:: _constructCombustionModel(combustionProperties: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary)

      Construct the combustion model.
      Might be overwritten in child to set additional parameters to combustionModelDict
      (fuel for PremixedCombustion model is updated in SparkIgnitionEngine)

      :param combustionProperties: the combustion properties
      :type combustionProperties: dict|Dictionary

      :returns: self
      :rtype: EngineModel



   .. py:method:: _updateMixtures() -> None

      Update mixture compositions (might be overwritten in child classes)



   .. py:method:: _updateCombustionModel()

      Update combustion model



   .. py:method:: __str__()


   .. py:method:: _loadFile(*args, **argv) -> EngineModel

      Loads a file with raw data to self.raw. See EngineData.loadFile
      documentation for arguments:



   .. py:method:: _loadArray(*args, **argv)

      Loads an array with raw data to self.raw. See EngineData.loadArray
      documentation for arguments:



   .. py:method:: loadData(dataPath: str = None, *, data: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary) -> EngineModel

      Load raw data.

      TODO: Info

      :param data: Dictionary containing the data to load for each region.
      :type data: dict | Dictionary
      :param dataPath: Global path where to load/write data. Defaults to None.
      :type dataPath: str, optional

      :returns: self
      :rtype: EngineModel



   .. py:method:: filterData(filter: Filter|FunctionType|None = None) -> EngineModel

      filter: Filter|FunctionType|None (optional)
          Filter to apply to raw data (e.g. resampling, low-pass filter, etc.). Required
          a method __call__(xp, yp)->(x,y) that resamples the dataset (xp,yp) to the
          datapoints (x,y).

      Filter the data in self.raw. Save the corresponding
      filtered data to self.data.
      If filter is None, data are cloned from self.raw



   .. py:method:: initializeThemodynamicModels(**initialConditions) -> EngineModel

      Set the initial conditions of all thermodynamic regions of the EngineModel.
      For region to be initialized, a dict is given for the inital conditions,
      according to the following convention:

      ->  If a float is given, the value is used
      ->  If a str is given, it refers to the name of the vabiables stored in the EngineModel,
          in which case the corresponding initial condition is sampled from the the corresponding
          data-set at self.time.startTime.
      ->  If string starting with @ is given, it applies that method with input (self.time.startTime)

      Ex:
      {
          "pressure": "p",            #This interpolates self.data.p at self.time.startTime
          "mass": 1.2e-3,             #Value
          "volume": "@geometry.V"     #Evaluates self.geometry.V(self.time.startTime)
      }

      :param \*\*initialConditions: data initialization of each zone in the model.



   .. py:method:: _preprocessThermoModelInput(inputDict: dict, zone: str) -> dict

      Auxiliary function to pre-process input dictionary
      to initialization of a thermodynamic region

      .. note::

         Might be overwritten in child class to also initialize
         the mixture composition, for example based on the combustion model.
         In such case, do so:
             def _preprocessThermoModelInput(self, inputDict:dict, zone:str) -> dict:
                 tempDict = super()._preprocessThermoModelInput(inputDict, zone)
         
                 ... #Manipulate mixture based on output dictionary
         
                 nameList = ["mass", "temperature", "pressure", "volume", "density"]
                 outputDict = {v:[tempDict[v]] for v in tempDict if v in nameList}   #Set state variables
                 outputDict["mixture"] = mix #Set mixture
         
                 return outputDict

      :param inputDict: dictionary for thermodynamic inputs
      :type inputDict: dict
      :param zone: the zone name
      :type zone: str

      :returns: processed dictionary
      :rtype: dict



   .. py:method:: preProcess(dataPath: str = None, *, data: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary, preProcessing: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary = None, initialConditions: dict | libICEpost.src.base.dataStructures.Dictionary.Dictionary, **junk) -> EngineModel

      Pre-processing:
          1) Loading data (from files or arrays)
          2) Pre-process the data (filtering, optional)
          3) Initialize thermodynamic regions

      NOTE:
      Naming of variables when loading data as follows:
          -> By default they refer to the "cylinder" zone
          -> Variables referred to a specific zone are allocated as "<variableName>_<zoneName>"

      TODO: example

      :param data: Dictionary with info for loading data.
      :type data: dict | Dictionary
      :param preProcessing: Dictionary with pre-processing information. Defaults to None.
      :type preProcessing: dict | Dictionary, optional
      :param dataPath: Master path of the tree. Defaults to None.
      :type dataPath: str, optional
      :param initialConditions: Dictionary with initial condition for thermodynamic models
      :type initialConditions: dict | Dictionary

      :returns: self
      :rtype: EngineModel



   .. py:method:: process() -> EngineModel

      Process the data, main time-loop.

      This is split into two function calls, which may be overwritten in child classes to tailored processings:
      1) _process__pre__: Create the columns in self.data for the fields generted by post-processing
      2) _update: The state-updating procedure in the main time-loop
      3) _process__post__: Final post-processing (e.g., computation of wall heat fluxes and rohr)

      :returns: self
      :rtype: EngineModel



   .. py:method:: _process__pre__() -> None

      Creation of the post-processed fields.

      .. note::

         When overwriting, first call this method:
         def _process__pre__(self) -> None:
             super()._process__pre__()
             ...



   .. py:method:: _update() -> None

      Method for updating the state during the time-loop. Here updating
      cylinder as single-zone model without interaction with other regions.
      Could be overwritten for more detailed models (e.g., two-zone SI model, TJI, etc.)

      .. note::

         When overwriting, afterwards call this method:
         def _update(self) -> None:
             ...
             super()._update()



   .. py:method:: _process__post__() -> None

      Computing wall heat fluxes and rohr

      .. note::

         When overwriting, first call this method:
         def _process__post__(self) -> None:
             ...
             super()._process__post__()



   .. py:method:: _computeWallHeatFlux() -> None

      Compute wall heat fluxes for each patch and global value in each region. Might be overloaded in child.



   .. py:method:: refresh(reset: bool = False) -> EngineModel

      Refresh data and restart processing:
          1) loadData
          2) filterData
          3) process

      :param reset: If need to restart from scratch. Defaults to False.
      :type reset: bool, optional

      :returns: self
      :rtype: EngineModel



   .. py:method:: integrateVariable(y: str, *, x: str = 'CA', start: float = None, end: float = None) -> float

      Integrate a variable over another.
      If inital or final CA are not given, are set to first/last in CA range.

      :param y: name of y variable.
      :type y: str
      :param x: Name of x variable. Defaults to "CA".
      :type x: str, optional
      :param start: Initial CA. Defaults to None.
      :type start: float, optional
      :param end: Final CA. Defaults to None.
      :type end: float, optional

      :returns: Integrated value
      :rtype: float



   .. py:method:: cumulativeIntegral(y: str, *, x: str = 'CA', start: float = None) -> numpy.ndarray

      Compute the cumulative integral of a variable over another.
      If start is not given, it is set to self.time.startOfCombustion.

      :param y: name of y variable.
      :type y: str
      :param x: Name of x variable. Defaults to "CA".
      :type x: str, optional
      :param start: Initial CA. Defaults to None.
      :type start: float, optional

      :returns: Cumulative integral function
      :rtype: pd.DataFrame



   .. py:method:: IMEP(start: float = None, end: float = None) -> float

      Compute indicated mean effective pressure.
      If inital or final CA are not given, are set to first/last in CA range.

      :param start: Initial CA. Defaults to None.
      :type start: float, optional
      :param end: Final CA. Defaults to None.
      :type end: float, optional

      :returns: IMEP [Pa]
      :rtype: float



   .. py:method:: work(start: float = None, end: float = None) -> float

      Compute indicated work (positive outgoing).
      If inital or final CA are not given, are set to first/last in CA range.

      :param start: Initial CA. Defaults to None.
      :type start: float, optional
      :param end: Final CA. Defaults to None.
      :type end: float, optional

      :returns: Work [J]
      :rtype: float



   .. py:method:: plotPV(/, *, start: float = None, end: float = None, loglog: bool = True, timingsParams: dict = dict(), **kwargs)

      Create the pressure-volume diagram of the thermodynamic cycle.

      :param start: The beginning of the plot (CA). Defaults to None.
      :type start: float, optional
      :param end: The end of the plot (CA). Defaults to None.
      :type end: float, optional
      :param loglog: log-log scale. Defaults to True.
      :type loglog: bool, optional
      :param timingsParams: The kwargs for the scatter for timings. Defaults to:
      :type timingsParams: dict, optional
      :param {: "edgecolor":"k",
                "zorder":2,
      :param }:



