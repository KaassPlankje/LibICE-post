libICEpost.src.base.Filter.LowPass
==================================

.. py:module:: libICEpost.src.base.Filter.LowPass

.. autoapi-nested-parse::

   @author: <N. Surname>       <e-mail>
   Last update:        DD/MM/YYYY



Classes
-------

.. autoapisummary::

   libICEpost.src.base.Filter.LowPass.LowPass


Module Contents
---------------

.. py:class:: LowPass(cutoff: float, *, order=5)

   Bases: :py:obj:`libICEpost.src.base.Filter.Filter.Filter`


   Apply low-pass filter

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. attribute:: cutoff

      float
      Cutoff frequency

   .. attribute:: order

      int
      Order of the filter


   .. py:property:: cutoff
      :type: float

      cutoff frequency

      :returns: float


   .. py:property:: order
      :type: int

      Order of the filter

      :returns: int


   .. py:method:: fromDictionary(dictionary)
      :classmethod:


      Create from dictionary.

      {
          cutoff (float): cutoff frequency
          order (int): order of the filter
      }



   .. py:method:: __call__(xp: list[float], yp: list[float]) -> tuple[list[float],list[float]]

      Filter an array of x,y data with low-pass filter



   .. py:method:: __repr__() -> str


   .. py:method:: _butter_lowpass(cutoff: float, fs: float, order: int = 5)


   .. py:method:: _butter_lowpass_filter(data: list[float], cutoff: float, fs: float, order: int = 5)


   .. py:method:: _preProcess(xp: list[float], yp: list[float]) -> tuple[list[float],list[float],float]

      Pre-process data to uniform time-step (equal to minimum time-step found in list).

      :returns: [resampled x, resampled y, delta]
      :rtype: tuple[list[float],list[float],float]



   .. py:method:: plot(xp: list[float], yp: list[float], *, xName: str|None = None, yName: str|None = None, freqUnits: str|None = None, c='b', **kwargs) -> tuple[mpl.Figure, np.ndarray[mpl.axes.Axes]]

      TODO



